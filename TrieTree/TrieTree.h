#ifndef ZL_TRIETREE_H
#define ZL_TRIETREE_H
#include <stddef.h>
#include <stdint.h>

//Trie树，又称单词查找树、字典树，是一种树形结构，是一种哈希树的变种，是一种用于快速检索的多叉树结构。
//典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
//思想 : 空间换时间, 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的;
//优点 : 最大限度地减少无谓的字符串比较，查询效率比哈希表高;
//缺点 : 内存消耗非常大.当然, 或许用左儿子右兄弟的方法建树的话, 可能会好点;
//
//三个基本特性：　　
//  1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。　　
//  2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。　
//  3. 每个节点的所有子节点包含的字符都不相同。
//
//查找分析
//  在trie树中查找一个关键字的时间和树中包含的结点数无关，而取决于组成关键字的字符数。而二叉查找树的查找时间和树中的结点数有关O(log2n)。
//  如果要查找的关键字可以分解成字符序列且不是很长，利用trie树查找速度优于二叉查找树。
//  如：若关键字长度最大是5，则利用trie树，利用5次比较可以从26 ^ 5＝11881376个可能的关键字中检索出指定的关键字。
//
//应用：
//  1. 字符串检索，词频统计，搜索引擎的热门查询
//      事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
//      和二叉查找树不同，在trie树中，每个结点上并非存储一个元素。trie树把要查找的关键词看作一个字符序列。并根据构成关键词字符的先后顺序构造用于检索的树结构。
//      在trie树上进行检索类似于查阅英语词典。
//      举例：
//          1）有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
//          2）给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
//          3）给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。
//          4）1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串
//          5）寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1 - 255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。
//  2. 字符串最长公共前缀
//      Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
//      举例：
//          1) 给出N 个小写英文字母串，以及Q个询问，即询问某两个串的最长公共前缀的长度是多少.解决方案：
//          首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线  （Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
//          而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
//              1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
//              2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了.
//  3. 排序
//      Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
//  4. 作为其他数据结构和算法的辅助结构
//      如后缀树，AC自动机等。

namespace zl
{
    namespace stl
    {
        //FIXME : 尚未全部完成，也有很多可以优化的实现

        const static int BRANCH_NUM = 26;   // 26个分支，也即是单词中只含有字母（a-z,A-Z），且没有标点符号，不区分大小写；若大小写敏感，则是52； 若加上数字0-9，则是62；

        class TrieNode
        {
        public:
            TrieNode()
            {
                id_ = 0;
                freq_ = 0;
                for (int i = 0; i < BRANCH_NUM; ++i)
                {
                    branch_[i] = NULL;
                }
            }

            uint64_t id_;    
            uint64_t freq_;  // 该单词出现的频率
            TrieNode* branch_[BRANCH_NUM];
        };

        class TrieTree
        {
        public:
            TrieTree();
            ~TrieTree();

        public:
            /// 查找word是否存在，id为该word的tag，为NULL表示不关注
            /// 返回-1 表示该word不存在，返回>0表示该word查找成功时所处的层次数
            int search(const char* word, uint64_t* id) const;

            /// 插入word， id为该word的tag，大于0时有效，否则表示不关注tag
            /// 返回-1 表示该word已存在，返回>0表示该word插入成功时所处的层次数
            int insert(const char* word, uint64_t id);

            /// 更新word的出现频率（如果word还不存在，就会插入到trie中, 如果存在，累加freq_， 如果id>0,同时更新id_）
            /// 返回-1 表示该word已存在，返回>0表示该word所处的层次数
            int update(const char* word, uint64_t id = 0);

            /// 移除word：注意这里的remove并没有释放内存，仅仅是重置了该word的freq_
            /// 返回-1 表示该word不存在，返回>0表示该word移除成功时所处的层次数
            int remove(const char* word, uint64_t* id);

            /// 统计word出现的频率
            int count(const char* word);

        private:
            int insertOrUpdate(const char* word, uint64_t id, bool updateIfExist);
            TrieNode* getNode(const char* word);

        private:
            TrieNode* root_;
        };
    }
}

#endif  /* ZL_TRIETREE_H */